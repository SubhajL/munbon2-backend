# -*- coding: utf-8 -*-
"""Water Gate Controller V 1.2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sKp_yAeTxNXaxoBNu5oLM91QTOpcJCQv

## คู่มือการใช้งาน

### อินพุตและเอาต์พุต
1. Input: ส่วนที่จำเป็นมีสองไฟล์และมี Option อีกหนึ่งไฟล์ ประกอบด้วย
   1. Structure.xlsx เก็บโครงสร้างของคลองส่งน้ำ
   2. Scada Section Detailed Information.xlsx เก็บความต้องการน้ำ ความเร็วน้ำที่ผ่านประตูน้ำ และอื่น ๆ (สามารถใช้ไฟล์ชื่ออื่น ๆ ได้ โดยอัปโหลดด้วยแท็บด้านซ้ายมือ จากนั้นให้แก้ชื่อไฟล์ใน cell `Initialization` บรรทัดที่ 35)
   3. Excel File เก็บสถานะปัจจุบันของประตูน้ำ มีรูปแบบเดียวกันกับไฟล์ Output
2. Output: มีสองรูปแบบ คือ jobs.xlsx และเก็บลง Database

### ขั้นตอนการทำงาน
1. Section Data Preparation ทำหน้าที่ download file อินพุตที่จำเป็น ซึ่งตรงนี้สามารถ upload ขึ้นจากเครื่องคอมพิวเตอร์ใด ๆ ได้ โดยใช้แท็บด้านซ้ายมือ
2. Section Display Structure ใช้แสดงโครงสร้าง (ไม่จำเป็นต้อง run ก็ได้)
3. Section Calculation ส่วนนี้จำเป็นต้องรัน เพื่อคำนวณลำดับการเปิดปิดประตูน้ำ
4. Section Export to jobs.xlsx เป็นไฟล์ผลลัพธ์ แสดงลำดับการเปิดปิดประตูน้ำ
5. Section Export to SQL Server เป็นแบบฟอร์มที่ต้องกรอกรายละเอียดของ Server ซึ่งเมื่อทำงานเสร็จ จะได้ table ชื่อ tb_tasks ในรูปแบบเดียวกับ jobs.xlsx

## Data Preparation
"""

! wget https://github.com/ssukree/water_gate/raw/main/Structure.xlsx
! wget https://github.com/ssukree/water_gate/raw/main/SCADA%20Section%20Detailed%20Information%202024-01-15%20V0.9%20SL.xlsx

import pandas as pd

structure_df=pd.read_excel('Structure.xlsx')
structure_df

import networkx as nx

edges = list(zip(structure_df['Source'], structure_df['Target']))

# Create a directed graph using NetworkX
G = nx.DiGraph()

# Add edges to the graph
G.add_edges_from(edges)
G.add_edge('S','M(0,0)')

"""## Display Structure"""

import matplotlib.pyplot as plt
pos = nx.drawing.nx_pydot.graphviz_layout(G, prog='dot')  # Use Graphviz for layout
plt.figure(figsize=(12, 15))

# Draw the graph
nx.draw(G, pos, with_labels=True, node_size=500, node_color='skyblue', arrowsize=10)

# Show the plot
plt.show()

"""## Calculation

### Initialization
"""

import pandas as pd

def initialize(requirement_filename):
  req_df=pd.read_excel(requirement_filename,skiprows=1)
  req_df=req_df[['Gate Valve','q_max (m^3/s)','Required Daily Water (cm)','Required Daily Volume (m3)']].dropna(subset=['Gate Valve'])
  gate_info=req_df.fillna(0).set_index('Gate Valve').to_dict(orient='index')
  all_open_gates=set()
  for g in req_df[req_df['Required Daily Volume (m3)'] > 0]['Gate Valve']:
    all_open_gates=all_open_gates.union(set(nx.shortest_path(G,'S',g)))
  adjustable_gates=[g for g in all_open_gates if g[0] != 'J']
  current_G=G.subgraph(all_open_gates)
  for node in G.nodes:
    for n in G.neighbors(node):
      if n in gate_info:
        gate_info[n]['parent'] = node
      else:
        gate_info[n]=dict()
        gate_info[n]['parent'] = node
  for n in adjustable_gates:
    if n in gate_info and gate_info[n]['q_max (m^3/s)'] > 0:
      current_G[gate_info[n]['parent']][n]['capacity'] = gate_info[n]['q_max (m^3/s)']
  working_G = nx.DiGraph()
  working_G.add_nodes_from(current_G.nodes(data=True))  # Include node attributes
  working_G.add_edges_from(current_G.edges(data=True))
  for g in gate_info:
    if 'Required Daily Volume (m3)' in gate_info[g]:
      if gate_info[g]['Required Daily Volume (m3)'] > 0:
        working_G.add_edge(g,'T')
  return working_G,gate_info

edges = list(zip(structure_df['Source'], structure_df['Target']))
G = nx.DiGraph()
G.add_edges_from(edges)
G.add_edge('S','M(0,0)')
working_G,gate_info=initialize('SCADA Section Detailed Information 2024-01-15 V0.9 SL.xlsx')

"""#### Actual Calculation"""

import math
import matplotlib.pyplot as plt
import networkx as nx
import warnings

def get_detail_operation(flow_dict,gate_info,minute_step):
  ret=[]
  for u in flow_dict:
    for v in flow_dict[u]:
      if flow_dict[u][v] > 0:
        if v in gate_info and 'q_max (m^3/s)' in gate_info[v]:
          if gate_info[v]['q_max (m^3/s)'] == 0:
            f_rate = flow_dict[u][v]
          else:
            f_rate = gate_info[v]['q_max (m^3/s)']
          if v == 'M(0,0)':
            ret.append({'Gate Valve':v,'Flow':flow_dict[u][v],'Time':minute_step,'Percent':round(100*flow_dict[u][v]/f_rate,2),'gate_level':-1})
          else:
            ret.append({'Gate Valve':v,'Flow':flow_dict[u][v],'Time':minute_step,'Percent':round(100*flow_dict[u][v]/f_rate,2),'gate_level':3})
  return ret

def update_gates(flow_dict,gate_info,minute_step,filled_area):
  for u in filled_area:
    gate_info[u]['Required Daily Volume (m3)'] = max(0,gate_info[u]['Required Daily Volume (m3)']-minute_step*60*filled_area[u]['q_max'])
    print('Fill Area: ',u,round(minute_step*60*filled_area[u]['q_max'],0))

def update_graph(gate_info,G):
  all_open_gates=set()
  for g in gate_info:
    if 'Required Daily Volume (m3)' in gate_info[g] and gate_info[g]['Required Daily Volume (m3)'] > 0:
      all_open_gates=all_open_gates.union(set(nx.shortest_path(G,'S',g)))
  adjustable_gates=[g for g in all_open_gates if g[0] != 'J']
  current_G=G.subgraph(all_open_gates)
  for n in adjustable_gates:
    if n in gate_info and gate_info[n]['q_max (m^3/s)'] > 0:
      current_G[gate_info[n]['parent']][n]['capacity'] = gate_info[n]['q_max (m^3/s)']
  working_G = nx.DiGraph()
  working_G.add_nodes_from(current_G.nodes(data=True))  # Include node attributes
  working_G.add_edges_from(current_G.edges(data=True))
  for g in gate_info:
    if 'Required Daily Volume (m3)' in gate_info[g]:
      if gate_info[g]['Required Daily Volume (m3)'] > 0:
        working_G.add_edge(g,'T')
  return working_G

def show_graph(flow_dict):
  show_G = nx.DiGraph()
  for u in flow_dict:
    for v in flow_dict[u]:
      if flow_dict[u][v] > 0:
        v_label = f'Fill {u}' if v == 'T' else v
        show_G.add_edge(u,v_label,label=str(round(flow_dict[u][v],3)))
  edge_labels = nx.get_edge_attributes(show_G, "label")
  with warnings.catch_warnings():
    warnings.simplefilter("ignore")
    plt.figure(figsize=(12, 20))
    pos = nx.nx_pydot.graphviz_layout(show_G, prog='dot')
    nx.draw(show_G, pos, with_labels=True)
    nx.draw_networkx_edge_labels(show_G, pos, edge_labels=edge_labels)
    plt.show()

operations=[]
steps=1
while True:
  print('\nStep',steps)
  steps+=1
  flow_value, flow_dict = nx.algorithms.flow.maximum_flow(working_G, 'S', 'T')
  filled_area = dict()
  for u in flow_dict:
    for v in flow_dict[u]:
      if v == 'T' and flow_dict[u][v] > 0:
        filled_area[u] = {'q_max':flow_dict[u][v],'fill_time':math.ceil(gate_info[u]['Required Daily Volume (m3)']/flow_dict[u][v])}
  if len([filled_area[u]['fill_time'] for u in filled_area]) == 0:
    break
  time_step=min([filled_area[u]['fill_time'] for u in filled_area])
  minute_step=math.ceil(time_step/60)
  print(minute_step,'mins')
  operations.append(get_detail_operation(flow_dict,gate_info,minute_step))
  update_gates(flow_dict,gate_info,minute_step,filled_area)
  show_graph(flow_dict)
  working_G = update_graph(gate_info,G)
  if len(working_G.nodes) == 0:
    break

"""## Export output to jobs.xlsx file"""

from datetime import datetime, timedelta
import os

def get_gate_name(gv):
  gate_name_info={'M(0,3)':{'gate_name':'gate7'},
                  'M (0,2: 1,0)':{'gate_name':'gate6'},
                  'M (0,2: 1,2)':{'gate_name':'gate4'},
                  'M(0,2; 1,1; 1,0)':{'gate_name':'gate5'},
                  'M(0,2; 1,1; 1,1)':{'gate_name':'gate3'},
                  'M(0,2; 1,1; 1,2)':{'gate_name':'gate1'},
                  'M(0,2; 1,1; 1,2; 1,0)':{'gate_name':'gate2'}}
  if gv not in gate_name_info:
    return gv
  return gate_name_info[gv]['gate_name']

def is_exist(f):
  return os.path.exists(f)

def export_excel(operations,start_time,filename,status_filename):
  if not os.path.exists(status_filename):
    current_open = set()
  else:
    current_open = set(pd.read_excel(status_filename)['Gate Valve'].unique())
  jobs=[]
  start_time = datetime.strptime(start_time, "%I:%M %p %d %b %y")
  for op in operations:
    time_step = op[0]['Time']
    newly_open = set()
    for task in op:
      task['Time'] = datetime.strftime(start_time, "%I:%M %p %d %b %y")
      task['gate_level'] = task['gate_level']
      task['gate_name'] = get_gate_name(task['Gate Valve'])
      task['completestatus'] = 1
      task['startdatetime'] = start_time
      jobs.append(task)
      newly_open.add(task['Gate Valve'])
    for g in current_open-newly_open:
      close_task = dict()
      close_task['Gate Valve'] = g
      close_task['Time'] = datetime.strftime(start_time, "%I:%M %p %d %b %y")
      close_task['Flow'] = 0
      close_task['Percent'] = 0
      close_task['gate_level'] = 0
      close_task['gate_name'] = get_gate_name(g)
      close_task['completestatus'] = 1
      close_task['startdatetime'] = start_time
      jobs.append(close_task)
    current_open = newly_open
    start_time = start_time + timedelta(minutes=time_step)
  for g in current_open:
    close_task = dict()
    close_task['Gate Valve'] = g
    close_task['Time'] = datetime.strftime(start_time, "%I:%M %p %d %b %y")
    close_task['Flow'] = 0
    close_task['Percent'] = 0
    close_task['gate_level'] = 0
    close_task['gate_name'] = get_gate_name(g)
    close_task['completestatus'] = 1
    close_task['startdatetime'] = start_time
    jobs.append(close_task)
  df=pd.DataFrame(jobs)
  df.to_excel(filename,index=None)
export_excel(operations,'8:00 am 12 Dec 23','jobs.xlsx','current_open.xlsx')

"""## Export to SQL Server"""

# @title Installation
server_ip = "182.53.226.237" # @param {type:"string"}
username = "sa" # @param {type:"string"}
password = "bangkok1234" # @param {type:"string"}
database_name = "db_scada" # @param {type:"string"}

# Commented out IPython magic to ensure Python compatibility.
# %%sh
# apt-get install -y unixodbc-dev
# curl https://packages.microsoft.com/keys/microsoft.asc | apt-key add -
# curl https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/prod.list > /etc/apt/sources.list.d/mssql-release.list
# sudo apt-get update
# sudo ACCEPT_EULA=Y apt-get -q -y install msodbcsql17

! pip install pyodbc

import pyodbc

def clear_table(conn_str,table_name):
  connection = pyodbc.connect(conn_str)
  cursor = connection.cursor()
  table_query = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'"
  cursor.execute(table_query)
  tables = cursor.fetchall()
  if table_name.split('.')[-1] in [table.TABLE_NAME for table in tables]:
      cursor.execute(f'DROP TABLE {table_name}')
      connection.commit()
  cursor.close()
  connection.close()

conn_str = f'DRIVER={{ODBC Driver 17 for SQL Server}};SERVER={server_ip};DATABASE={database_name};UID={username};PWD={password}'
clear_table(conn_str,'dbo.tb_tasks')
clear_table(conn_str,'dbo.tb_gatelevel_command')
connection = pyodbc.connect(conn_str)
cursor = connection.cursor()
df = pd.read_excel('jobs.xlsx')
table_name = 'dbo.tb_tasks'
create_table_query = f"CREATE TABLE {table_name} (gate_name VARCHAR(255), gate_level INT, startdatetime DATETIME, completestatus INT)"
cursor.execute(create_table_query)
connection.commit()
insert_query = f"INSERT INTO {table_name} ({', '.join(['gate_name','gate_level','startdatetime','completestatus'])}) VALUES (?, ?, ?, ?)"
cursor.executemany(insert_query, df[['gate_name','gate_level','startdatetime','completestatus']].values.tolist())
connection.commit()
table_name = 'dbo.tb_gatelevel_command'
create_table_query = f"CREATE TABLE {table_name} (gate_name VARCHAR(255), gate_level INT, startdatetime DATETIME, completestatus INT)"
cursor.execute(create_table_query)
connection.commit()
insert_query = f"INSERT INTO {table_name} ({', '.join(['gate_name','gate_level','startdatetime','completestatus'])}) VALUES (?, ?, ?, ?)"
cursor.executemany(insert_query, df[df['gate_name'].str.contains('gate')][['gate_name','gate_level','startdatetime','completestatus']].values.tolist())
connection.commit()
cursor.close()
connection.close()