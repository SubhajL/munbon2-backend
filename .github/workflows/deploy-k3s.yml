name: Deploy to K3s

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      service:
        description: 'Service to deploy (leave empty for all)'
        required: false
        type: string

env:
  REGISTRY: docker.io
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.build.outputs.images }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push images
        id: build
        run: |
          IMAGES=""
          SERVICES_DIR="services"
          
          # Determine which services to build
          if [ -n "${{ github.event.inputs.service }}" ]; then
            SERVICES="${{ github.event.inputs.service }}"
          else
            SERVICES=$(find $SERVICES_DIR -maxdepth 1 -type d -name "*-service" | xargs -n1 basename)
          fi
          
          # Build and push each service
          for SERVICE in $SERVICES; do
            if [ -f "$SERVICES_DIR/$SERVICE/Dockerfile" ]; then
              echo "Building $SERVICE..."
              IMAGE_TAG="${REGISTRY}/${DOCKER_USERNAME}/$SERVICE:${{ github.sha }}"
              
              docker build -t $IMAGE_TAG "$SERVICES_DIR/$SERVICE"
              docker push $IMAGE_TAG
              
              # Also tag as latest
              docker tag $IMAGE_TAG "${REGISTRY}/${DOCKER_USERNAME}/$SERVICE:latest"
              docker push "${REGISTRY}/${DOCKER_USERNAME}/$SERVICE:latest"
              
              IMAGES="$IMAGES $SERVICE:${{ github.sha }}"
            fi
          done
          
          echo "images=$IMAGES" >> $GITHUB_OUTPUT

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to K3s
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG_BASE64 }}
        run: |
          # Set up kubectl
          echo "$KUBE_CONFIG" | base64 -d > kubeconfig
          export KUBECONFIG=$(pwd)/kubeconfig
          
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          
          # Apply base configurations
          kubectl apply -f k8s/base/namespace.yaml
          kubectl apply -f k8s/base/configmap.yaml
          
          # Deploy databases if not exists
          kubectl get deployment redis -n munbon || kubectl apply -f k8s/services/redis.yaml
          kubectl get deployment postgres -n munbon || kubectl apply -f k8s/services/postgres.yaml
          
          # Update service images
          IMAGES="${{ needs.build-and-push.outputs.images }}"
          for IMAGE_INFO in $IMAGES; do
            SERVICE=$(echo $IMAGE_INFO | cut -d: -f1)
            TAG=$(echo $IMAGE_INFO | cut -d: -f2)
            
            # Update deployment with new image
            kubectl set image deployment/$SERVICE $SERVICE=${{ env.REGISTRY }}/${{ env.DOCKER_USERNAME }}/$SERVICE:$TAG -n munbon || true
          done
          
          # Wait for rollout
          for IMAGE_INFO in $IMAGES; do
            SERVICE=$(echo $IMAGE_INFO | cut -d: -f1)
            kubectl rollout status deployment/$SERVICE -n munbon --timeout=300s || true
          done
          
          # Show deployment status
          kubectl get all -n munbon

  notify:
    needs: [build-and-push, deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Send notification
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "✅ Deployment successful!"
          else
            echo "❌ Deployment failed!"
          fi